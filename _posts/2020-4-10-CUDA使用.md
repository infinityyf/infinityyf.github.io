---
layout:     post
title:      CUDA
subtitle:   
date:       2020-04-10
author:     infinityyf
header-img: img/tag-bg-o.jpg
catalog: true
tags:
    - CUDA
---

# 基本使用  
在CPU端定义函数，上传到GPU端定义
```c
__global__ void helloWorldGPU(void) {
	std::cout << "hello" << std::endl;
}

//使用该函数启动内核代码
helloWorldGPU<<<1,10>>>()//启动10个线程

cudaDeviceRest//使用该函数释放和清空当前设备持有的资源
```
1. 使用步骤  
分配内存  
将CPU数据拷贝到GPU  
调用CUDA核函数  
拷贝回CPU  
释放GPU内存  

2. 内存管理  
使用cudaMalloc分配线性内存，使用cudaMemset,cudaMemcpy,cudaFree进行管理，这些函数将在GPU全局内存中分配。cudaMemcpy的调用混导致主机的阻塞  

3. 线程管理  
cuda使用两层的线程层次结构。一个内核启动所有的线程统称一个网格。同一个网格中的线程共享相同的全局内存空间。一个网格由多个线程块构成，一个线程块包含一组线程。CUDA在运行时会为每个线程分配坐标变量，blockIdx,threadIdx,通过这些变量将数据分配给线程。  

这两个变量是基于uint3实现的，所以每个都有xyz三个分量。网格的维度核线程块的维度通过blockDim，gridDim来查询，同样也是包含三个分量。  

一般网格回被组织成线程块的二维数组，而线程块为线程的三维数组。  

4. 启动核函数  
grid和block均可以自定义  
kernalname<<<grid,block>>>()  
grid：网格的维度  
block: 块的维度  
在核函数中使用__syncthreads()同步所有线程块中的线程

使用cudaDeviceSynchronize强制使主机端程序等待所有的核函数执行结束  

5. 在其他文件中调用  
用来被调用的CUDA函数中要加上extern "C" 的声明，并在cpp文件中进行声明（extern "C" int runtest(int *host_a, int *host_b, int *host_c);）后再调用    


## 一些概念  
1. warp 
warp是基本的执行单元，包含32个并行thread，一个线程块的thread只能在一个SM上调度  
2. SP  
最基本的处理单元，也称为CUDA core  
3. SM  
多个SP组成SM  
4. 不同划分的threadid计算方法  
grid划分成1维，block划分为1维  
int threadId = blockIdx.x *blockDim.x + threadIdx.x;  

grid划分成1维，block划分为2维  
int threadId = blockIdx.x * blockDim.x * blockDim.y+ threadIdx.y * blockDim.x + threadIdx.x;  

grid划分成1维，block划分为3维  
int threadId = blockIdx.x * blockDim.x * blockDim.y * blockDim.z + threadIdx.z * blockDim.y * blockDim.x + threadIdx.y * blockDim.x + threadIdx.x;  

grid划分成2维，block划分为1维  
int blockId = blockIdx.y * gridDim.x + blockIdx.x;  
int threadId = blockId * blockDim.x + threadIdx.x;  

grid划分成2维，block划分为2维  
int blockId = blockIdx.x + blockIdx.y * gridDim.x;  
int threadId = blockId * (blockDim.x * blockDim.y)+ (threadIdx.y * blockDim.x) + threadIdx.x;  

grid划分成2维，block划分为3维  
int blockId = blockIdx.x + blockIdx.y * gridDim.x;  
int threadId = blockId * (blockDim.x * blockDim.y * blockDim.z) + (threadIdx.z * (blockDim.x * blockDim.y))+ (threadIdx.y * blockDim.x) + threadIdx.x;  

grid划分成3维，block划分为1维  
int blockId = blockIdx.x + blockIdx.y * gridDim.x+ gridDim.x * gridDim.y * blockIdx.z;  
int threadId = blockId * blockDim.x + threadIdx.x;  

grid划分成3维，block划分为2维  
int blockId = blockIdx.x + blockIdx.y * gridDim.x+ gridDim.x * gridDim.y * blockIdx.z;  
int threadId = blockId * (blockDim.x * blockDim.y)+ (threadIdx.y * blockDim.x) + threadIdx.x;  

grid划分成3维，block划分为3维  
int blockId = blockIdx.x + blockIdx.y * gridDim.x+ gridDim.x * gridDim.y * blockIdx.z;  
int threadId = blockId * (blockDim.x * blockDim.y * blockDim.z)+ (threadIdx.z * (blockDim.x * blockDim.y))+ (threadIdx.y * blockDim.x) + threadIdx.x;  

