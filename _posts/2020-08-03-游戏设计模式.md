---
layout:     post
title:      游戏设计模式
subtitle:   
date:       2020-08-03
author:     infinityyf
header-img: img/tag-bg-o.jpg
catalog: true
tags:
    - game
--- 

# 前言：评价架构设计的好坏就是评价它应对改动有多容易，架构的目标就是最小化在编写代码前需要了解的信息

[1.命令模式](#1)
[2.享元模式](#2)
[3.观察者模式](#3)
[4.原型模式](#4)


<h1 id="1">1.命令模式</h1>

命令是具体化的方法调用。将方法调用存储在对象中，是一种面向对象的回调。以游戏中的输入为例：  
程序获取用户输入，然后转化为游戏角色的某种行为

```c
void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) lurchIneffectively();
  //如果经常按b就会每次进行四次判断
}
```  

但是现在有一个需求，就是支持用户改键。  
定义一个命令类，记录可以触发的游戏行为：

```c
class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
};
```  

然后为每个行为定义相应的子类：

```c
class JumpCommand : public Command
{
public:
  virtual void execute() { jump(); }
};

class FireCommand : public Command
{
public:
  virtual void execute() { fireGun(); }
};
```  

然后为每个按键存储一个指向命令的指针

```c
class InputHandler
{
public:
  void handleInput();

  // 绑定命令的方法……

private:
  Command* buttonX_;
  Command* buttonY_;
  Command* buttonA_;
  Command* buttonB_;//就是按键B这里就和一个命令进行了绑定，之后还可以修改
};
```

之后的逻辑就变成了：

```c
void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) buttonX_->execute();
  else if (isPressed(BUTTON_Y)) buttonY_->execute();
  else if (isPressed(BUTTON_A)) buttonA_->execute();
  else if (isPressed(BUTTON_B)) buttonB_->execute();
}
```

现在还有一个问题，就是行为是去找角色进行执行的，我们希望角色自己去找命令执行，所有这里就需要把角色的引用传递给一个函数

```c
class Command
{
public:
  virtual ~Command() {}
  virtual void execute(GameActor& actor) = 0;
};
class JumpCommand : public Command
{
public:
  virtual void execute(GameActor& actor)
  {
    actor.jump();
  }
};
```

修改输入模块：

```c
Command* InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) return buttonX_;
  if (isPressed(BUTTON_Y)) return buttonY_;
  if (isPressed(BUTTON_A)) return buttonA_;
  if (isPressed(BUTTON_B)) return buttonB_;

  // 没有按下任何按键，就什么也不做
  return NULL;
}
Command* command = inputHandler.handleInput();
if (command)
{
  command->execute(actor);
}
```

将命令和角色解耦，方便AI系统对其他角色进行指挥  

### 1.1 撤销与重做  

```c
class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit* unit, int x, int y)
  : unit_(unit),
    xBefore_(0),
    yBefore_(0),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    // 保存移动之前的位置
    // 这样之后可以复原。

    xBefore_ = unit_->x();
    yBefore_ = unit_->y();

    unit_->moveTo(x_, y_);
  }

  virtual void undo()
  {
    unit_->moveTo(xBefore_, yBefore_);
  }

private:
  Unit* unit_;
  int xBefore_, yBefore_;
  int x_, y_;
};

```

将命令用一个队列存储可以实现撤销 

### 补充

持久化数据结构：发生改变时，保存之前版本的数据结构，对数据进行操作时，不会在院数据上更新，而是生成新的数据再修改。例如net中的string,一旦创建了一个String类型实例，它便不能被改变了，对于欲改变其值的任何操作都将被产生一个新的String对象，通过这样，每一个版本的String实例都将被驻留下来。  
然而持久化的数据结构会带来一些开销，任何改变持久化数据结构的操作都将创建一个新的版本，这可能会涉及到大量的拷贝操作，通常我们可以通过重用旧版本对象的内部数据结构来创建一个新的对象，这种办法可以极大地降低拷贝操作所带来的消耗（公用重复的部分数据）  

<h1 id="2">2.享元模式</h1> 
很多对象有共有的数据,例如森林中的树,可以把mesh数据单独抽出来:(纯粹为了提高效率)
```c
class TreeModel
{
private:
  Mesh mesh_;
  Texture bark_;
  Texture leaves_;
};
class Tree
{
private:
  TreeModel* model_;

  Vector position_;
  double height_;
  double thickness_;
  Color barkTint_;
  Color leafTint_;
};

```  

另一个例子是地形的区块,不是在每个区块中保存状态,而是为每种地形使用一个类:

```c
class Terrain
{
public:
  Terrain(int movementCost,
          bool isWater,
          Texture texture)
  : movementCost_(movementCost),
    isWater_(isWater),
    texture_(texture)
  {}

  int getMovementCost() const { return movementCost_; }
  bool isWater() const { return isWater_; }
  const Texture& getTexture() const { return texture_; }

private:
  int movementCost_;
  bool isWater_;
  Texture texture_;
};
//每个区块指向对应的地形,好处在于对于重复的区块可以指向同一个地形
class World
{
private:
  Terrain* tiles_[WIDTH][HEIGHT];

  // 其他代码……
};
```  

但是为了动态分配的方便,直接在world类中进行存储:

```c
class World
{
public:
  World()
  //存储了所有的顶下==地形
  : grassTerrain_(1, false, GRASS_TEXTURE),
    hillTerrain_(3, false, HILL_TEXTURE),
    riverTerrain_(2, true, RIVER_TEXTURE)
  {}

private:
  Terrain grassTerrain_;
  Terrain hillTerrain_;
  Terrain riverTerrain_;

  // 其他代码……
};

//然后生成地形
void World::generateTerrain()
{
  // 将地面填满草皮.
  for (int x = 0; x < WIDTH; x++)
  {
    for (int y = 0; y < HEIGHT; y++)
    {
      // 加入一些丘陵
      if (random(10) == 0)
      {
        tiles_[x][y] = &hillTerrain_;
      }
      else
      {
        tiles_[x][y] = &grassTerrain_;
      }
    }
  }

  // 放置河流
  int x = random(WIDTH);
  for (int y = 0; y < HEIGHT; y++) {
    tiles_[x][y] = &riverTerrain_;
  }
}
```
