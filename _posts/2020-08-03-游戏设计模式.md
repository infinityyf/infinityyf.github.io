---
layout:     post
title:      游戏设计模式
subtitle:   
date:       2020-08-03
author:     infinityyf
header-img: img/tag-bg-o.jpg
catalog: true
tags:
    - game
--- 

# 前言：评价架构设计的好坏就是评价它应对改动有多容易，架构的目标就是最小化在编写代码前需要了解的信息

[1.命令模式](#1)
[2.享元模式](#2)
[3.观察者模式](#3)
[4.原型模式](#4)


<h1 id="1">1.命令模式</h1>

命令是具体化的方法调用。将方法调用存储在对象中，是一种面向对象的回调。以游戏中的输入为例：  
程序获取用户输入，然后转化为游戏角色的某种行为

```c
void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) lurchIneffectively();
  //如果经常按b就会每次进行四次判断
}
```  

但是现在有一个需求，就是支持用户改键。  
定义一个命令类，记录可以触发的游戏行为：

```c
class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
};
```  

然后为每个行为定义相应的子类：

```c
class JumpCommand : public Command
{
public:
  virtual void execute() { jump(); }
};

class FireCommand : public Command
{
public:
  virtual void execute() { fireGun(); }
};
```  

然后为每个按键存储一个指向命令的指针

```c
class InputHandler
{
public:
  void handleInput();

  // 绑定命令的方法……

private:
  Command* buttonX_;
  Command* buttonY_;
  Command* buttonA_;
  Command* buttonB_;//就是按键B这里就和一个命令进行了绑定，之后还可以修改
};
```

之后的逻辑就变成了：

```c
void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) buttonX_->execute();
  else if (isPressed(BUTTON_Y)) buttonY_->execute();
  else if (isPressed(BUTTON_A)) buttonA_->execute();
  else if (isPressed(BUTTON_B)) buttonB_->execute();
}
```

现在还有一个问题，就是行为是去找角色进行执行的，我们希望角色自己去找命令执行，所有这里就需要把角色的引用传递给一个函数

```c
class Command
{
public:
  virtual ~Command() {}
  virtual void execute(GameActor& actor) = 0;
};
class JumpCommand : public Command
{
public:
  virtual void execute(GameActor& actor)
  {
    actor.jump();
  }
};
```

修改输入模块：

```c
Command* InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) return buttonX_;
  if (isPressed(BUTTON_Y)) return buttonY_;
  if (isPressed(BUTTON_A)) return buttonA_;
  if (isPressed(BUTTON_B)) return buttonB_;

  // 没有按下任何按键，就什么也不做
  return NULL;
}
Command* command = inputHandler.handleInput();
if (command)
{
  command->execute(actor);
}
```

将命令和角色解耦，方便AI系统对其他角色进行指挥  

### 1.1 撤销与重做  

```c
class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit* unit, int x, int y)
  : unit_(unit),
    xBefore_(0),
    yBefore_(0),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    // 保存移动之前的位置
    // 这样之后可以复原。

    xBefore_ = unit_->x();
    yBefore_ = unit_->y();

    unit_->moveTo(x_, y_);
  }

  virtual void undo()
  {
    unit_->moveTo(xBefore_, yBefore_);
  }

private:
  Unit* unit_;
  int xBefore_, yBefore_;
  int x_, y_;
};

```

将命令用一个队列存储可以实现撤销 

### 补充

持久化数据结构：发生改变时，保存之前版本的数据结构，对数据进行操作时，不会在院数据上更新，而是生成新的数据再修改。例如net中的string,一旦创建了一个String类型实例，它便不能被改变了，对于欲改变其值的任何操作都将被产生一个新的String对象，通过这样，每一个版本的String实例都将被驻留下来。  
然而持久化的数据结构会带来一些开销，任何改变持久化数据结构的操作都将创建一个新的版本，这可能会涉及到大量的拷贝操作，通常我们可以通过重用旧版本对象的内部数据结构来创建一个新的对象，这种办法可以极大地降低拷贝操作所带来的消耗（公用重复的部分数据）  

<h1 id="2">2.享元模式</h1> 
很多对象有共有的数据,例如森林中的树,可以把mesh数据单独抽出来:(纯粹为了提高效率)
```c
class TreeModel
{
private:
  Mesh mesh_;
  Texture bark_;
  Texture leaves_;
};
class Tree
{
private:
  TreeModel* model_;

  Vector position_;
  double height_;
  double thickness_;
  Color barkTint_;
  Color leafTint_;
};

```  

另一个例子是地形的区块,不是在每个区块中保存状态,而是为每种地形使用一个类:

```c
class Terrain
{
public:
  Terrain(int movementCost,
          bool isWater,
          Texture texture)
  : movementCost_(movementCost),
    isWater_(isWater),
    texture_(texture)
  {}

  int getMovementCost() const { return movementCost_; }
  bool isWater() const { return isWater_; }
  const Texture& getTexture() const { return texture_; }

private:
  int movementCost_;
  bool isWater_;
  Texture texture_;
};
//每个区块指向对应的地形,好处在于对于重复的区块可以指向同一个地形
class World
{
private:
  Terrain* tiles_[WIDTH][HEIGHT];

  // 其他代码……
};
```  

但是为了动态分配的方便,直接在world类中进行存储:

```c
class World
{
public:
  World()
  //存储了所有的顶下==地形
  : grassTerrain_(1, false, GRASS_TEXTURE),
    hillTerrain_(3, false, HILL_TEXTURE),
    riverTerrain_(2, true, RIVER_TEXTURE)
  {}

private:
  Terrain grassTerrain_;
  Terrain hillTerrain_;
  Terrain riverTerrain_;

  // 其他代码……
};

//然后生成地形
void World::generateTerrain()
{
  // 将地面填满草皮.
  for (int x = 0; x < WIDTH; x++)
  {
    for (int y = 0; y < HEIGHT; y++)
    {
      // 加入一些丘陵
      if (random(10) == 0)
      {
        tiles_[x][y] = &hillTerrain_;
      }
      else
      {
        tiles_[x][y] = &grassTerrain_;
      }
    }
  }

  // 放置河流
  int x = random(WIDTH);
  for (int y = 0; y < HEIGHT; y++) {
    tiles_[x][y] = &riverTerrain_;
  }
}
```

<h1 id="3">3.观察者模式</h1> 

只是在某件事情发生的时候发出通知，而不用关心是谁接受到了通知。
观察者：

```c
class Observer
{
public:
  virtual ~Observer() {}
  virtual void onNotify(const Entity& entity, Event event) = 0;
};

class Achievements : public Observer
{
public:
  virtual void onNotify(const Entity& entity, Event event)
  {
    switch (event)
    {
    case EVENT_ENTITY_FELL:
      if (entity.isHero() && heroIsOnBridge_)
      {
        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
      }
      break;

      // 处理其他事件，更新heroIsOnBridge_变量……
    }
  }

private:
  void unlock(Achievement achievement)
  {
    // 如果还没有解锁，那就解锁成就……
  }

  bool heroIsOnBridge_;
};
```

被观察者则需要记录两个信息，一个是它的观察者列表（*需要一个公开的api去增减这个列表*），一个是发送通知:

```c
class Subject
{
protected:
  void notify(const Entity& entity, Event event)
  {
    for (int i = 0; i < numObservers_; i++)
    {
      observers_[i]->onNotify(entity, event);
    }
  }

  // 其他代码…………
};
```

需要注意的是，这样的机制是同步的，观察者的方法处理完之后，被观察者才能继续工作。所以最好使用*事件队列*进行异步的处理。

还有一个问题，就是内存的动态分配，主要是对于观察者列表。如何避免动态的内存分配：
可以使用*链式观察者*：
将观察者的列表分布到观察者自己种来解决动态分配。取消数组，而是记录一个观察者列表的头部指针:
```c
class Subject
{
  Subject()
  : head_(NULL)
  {}

  // 方法……
private:
  Observer* head_;
};

//在观察者种添加一个指向下一观察者的指针
class Observer
{
  friend class Subject;//是subject的友元，这样就可以增减观察者列表

public:
  Observer()
  : next_(NULL)
  {}

  // 其他代码……
private:
  Observer* next_;
};

void Subject::addObserver(Observer* observer)
{
  observer->next_ = head_;
  head_ = observer;
}
```

但是这样，一个观察者只能被一个被观察者记录，可以通过链表节点池来解决这个问题。每个被观察者有一个链表的观察者，但是链表节点不是观察者本身，而是分散的小的链表节点对象，这个对象包含了指向观察者的指针和指向链表下一个节点的指针。这样每个链表就可以独立的存储观察者的地址。使得观察者可以被重复引用。

![链表节点池](/img/gdp/observer-nodes.png) 

### 2.1销毁观察者或者被观察者  

可能导致被观察者指向一个空地址。所以析构的时候，自动取消注册


<h1 id="4">4.原型模式</h1> 

一个对象可以产出与它自己相近的对象，以monster例：
```c
class Monster
{
public:
  virtual ~Monster() {}
  virtual Monster* clone() = 0;

  // 其他代码……
};

class Ghost : public Monster {
public:
  Ghost(int health, int speed)
  : health_(health),
    speed_(speed)
  {}

  virtual Monster* clone()
  {
    return new Ghost(health_, speed_);
  }

private:
  int health_;
  int speed_;
};
```

不需要为每个怪物类创建生产者，定义一个类：
```c
class Spawner
{
public:
  Spawner(Monster* prototype)
  : prototype_(prototype)
  {}

  Monster* spawnMonster()
  {
    return prototype_->clone();//通过clone方法产生实例，使用父类的指针，但是还是调用子类的方法（多态）
  }

private:
  Monster* prototype_;//充当模板
};

Monster* ghostPrototype = new Ghost(15, 3);
Spawner* ghostSpawner = new Spawner(ghostPrototype);
```
一种更简洁的写法：
```c
//定义各种生产函数
Monster* spawnGhost()
{
  return new Ghost();
}

//生产类存储一个函数指针
typedef Monster* (*SpawnCallback)();

class Spawner
{
public:
  Spawner(SpawnCallback spawn)
  : spawn_(spawn)
  {}

  Monster* spawnMonster()
  {
    return spawn_();
  }

private:
  SpawnCallback spawn_;//一个函数指针，每次调用都会产生一个实例
};

//生成ghost
Spawner* ghostSpawner = new Spawner(spawnGhost);//spawnGhost是一个函数指针
```

